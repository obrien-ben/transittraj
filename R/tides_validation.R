#' Check if an AVL dataframe meets TIDES standards.
#'
#' @description
#' The transit integrated data exchange standard (TIDES) specifies columns that
#' should be present in AVL data tables and the data types of these columns.
#' This function verifies if those columns are present in the input `avl_df`,
#' and those columns are of the correct data type. See `Details` for
#' more information.
#'
#' @details
#' The AVL cleaning functions in this package generally require the input
#' dataframes to adhere to the TIDES `vehicle_locations`
#' [table schema](https://tides-transit.org/main/tables/#vehicle-locations). The
#' following columns and data types are checked by this validator:
#'
#' - `location_ping_id`: Should be a `character` string.
#'
#' - `trip_id_performed`: Should be a `character` string.
#'
#' - `event_timestamp`: Should be a `POSIXct` date-time.
#'
#' - `vehicle_id`: Should be a `character` string.
#'
#' - `operator_id`: Should be a `character` string. This field is not standard
#' in TIDES `vehicle_locations`, and is not a strict requirement for any AVL
#' processing functions.
#'
#' - `longitude` and `latitude`: Should be `numeric`. These fields are required
#' only to linearize AVL data, and not used afterwards.
#'
#' - `distance`: Should be `numeric`. This field is not standard in TIDES
#' `vehicle_locations`, and is generated by `get_linear_distances()`. It is
#' required by most other AVL processing functions.
#'
#' - `speed`: Should be `numeric`. This field is not a strict requirement for
#' any AVL processing functions.
#'
#' Each AVL processing function in `transittraj` uses specific fields. Each
#' function verifies that the required fields and data types are present before
#' proceeding.
#'
#' @param avl_df A dataframe of AVL data, either in GPS (longitude/latitude)
#' form or linearized distance form.
#' @return A dataframe of each required field, required data type, whether
#' the field is present, and whether the data type matches expectations.
#' @export
validate_tides <- function(avl_df) {
  # Set required columns & datatypes
  required_columns <- c("location_ping_id",
                        "trip_id_performed",
                        "event_timestamp",
                        "vehicle_id",
                        "operator_id",
                        "longitude", "latitude",
                        "distance",
                        "speed")
  required_data_types <- c("character",
                           "character",
                           "POSIXct",
                           "character",
                           "character",
                           "numeric", "numeric",
                           "numeric",
                           "numeric")

  # Get if each column is present in DF
  cols_present_bool <- required_columns %in% names(avl_df)

  # Check data types
  cols_types <- sapply(required_columns, FUN = function(current_col) {
    if (current_col %in% names(avl_df)) {
      return(class(avl_df[[current_col]])[1])
    } else {
      return(NA)
    }
  })
  names(cols_types) <- NULL
  cols_types_bool <- cols_types == required_data_types

  # Compile results into DF
  validation_results <- data.frame(required_field = required_columns,
                                   required_field_type = required_data_types,
                                   field_present = cols_present_bool,
                                   actual_field_type = cols_types,
                                   field_type_ok = cols_types_bool) %>%
    dplyr::mutate(field_ok = (field_type_ok & field_present))
  return(validation_results)
}

#' Check if an AVL dataframe satisfies assumptions of monotonicity.
#'
#' @description
#' This function checks whether the provided AVL dataframe of linearized
#' distances satisfies three conditions:
#'
#' - Weak monotonicity, either flat or increasing
#'
#' - Strict monotonicty, increasing only
#'
#' - Speeds satisfy Fritsch-Carlson constraints
#'
#' See `make_monotonic()` for more information.
#'
#' @param distance_df A dataframe of linearized AVL data. Must include
#' `trip_id_performed`, `event_timestamp`, and `distance`. If
#' `check_speed = TRUE`, must also include `speed`.
#' @param check_speed Optional. A boolean, should the Fritsch-Carlson conditions
#' @param return_full Optional. Should a dataframe of each point checked be
#' returned? Default is `FALSE`.
#' for slopes be checked? Default is `FALSE`, where the speed check will return
#' `NA`.
#' @return A named vector of booleans indicating whether each of the three
#' conditions are satisfied.
#' @export
validate_monotonicity <- function(distance_df, check_speed = FALSE,
                                  return_full = FALSE) {

  # Check for weak and strict position monotonicity by point.
  check_mon <- distance_df %>%
    dplyr::arrange(trip_id_performed, event_timestamp) %>%
    dplyr::group_by(trip_id_performed) %>%
    dplyr::mutate(is_weak = distance <= dplyr::lead(distance),
                  is_strict = distance < dplyr::lead(distance),
                  is_weak = tidyr::replace_na(is_weak, TRUE),
                  is_strict = tidyr::replace_na(is_strict, TRUE)) %>%
    dplyr::select(trip_id_performed, event_timestamp, distance, location_ping_id, is_weak, is_strict)

  if (check_speed) {
    # Compute FC statistics to check if speed will result in monotonic FC Hermite curve.
    check_speed_mon <- distance_df %>%
      dplyr::arrange(trip_id_performed, event_timestamp) %>%
      dplyr::group_by(trip_id_performed) %>%
      dplyr::mutate(time_sec = as.numeric(event_timestamp),
                    fc_delta = (dplyr::lead(distance) - distance) / (dplyr::lead(time_sec) / time_sec),
                    fc_alpha = speed / fc_delta,
                    fc_beta = dplyr::lead(speed) / fc_delta,
                    sum_sq = fc_alpha^2 + fc_beta^2,
                    is_fc_speed = (round(sum_sq, 5) <= 9),
                    is_fc_speed = tidyr::replace_na(is_fc_speed, TRUE)) %>%
      dplyr::select(trip_id_performed, event_timestamp, distance, is_fc_speed)
  } else {
    speed_check <- NA
  }

  if (return_full) {
    check_df <- check_mon %>%
      dplyr::left_join(y = check_speed_mon, by = c("trip_id_performed", "event_timestamp", "distance")) %>%
      dplyr::mutate(all_ok = (is_weak & is_strict & is_fc_speed))

    return(check_df)
  } else {
    # Check that all points satisfy conditions
    weak_check <- all(check_mon$is_weak)
    strict_check <- all(check_mon$is_strict)
    speed_check <- all(check_speed_mon$is_fc_speed)

    # Combine all checks into named vector
    check_results <- c("weak" = weak_check,
                       "strict" = strict_check,
                       "speed" = speed_check)

    return(check_results)
  }
}

#' Uses `validate_tides` and an input vector of needed fields to check whether
#' an AVL DF meets the requirements of a given function.
#'
#' Intended for internal use only.
#'
#' @param needed_fields Vector of fields desired
#' @param avl_df DF of TIDES AVL data
#' @return boolean for each field
validate_input_to_tides <- function(needed_fields, avl_df) {

  # Get validation -- filter & sort
  avl_val <- validate_tides(avl_df) %>%
    dplyr::filter(required_field %in% needed_fields) %>%
    dplyr::arrange(match(required_field, needed_fields))

  # Check presence of fields
  if (!all(avl_val$field_present)) {
    rlang::abort(paste(c("Missing required fields:",
                         avl_val$required_field[!avl_val$field_present]),
                       collapse = " "),
                 class = "error_tidesval_missing_fields")
  }

  # Check data types of fields
  if (!all(avl_val$field_type_ok)) {
    rlang::abort(paste(c("The following fields do not have the correct data type:",
                         avl_val$required_field[!avl_val$field_type_ok]),
                       collapse = " "),
                 class = "error_tidesval_field_datatype")
  }
}
