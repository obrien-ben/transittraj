---
title: "Introduction to Trajectory Objects"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{trajectories}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

In the previous vignette, we saw how we can use `transittraj` to clean our
AVL data. We took care of outliers, deadheading trips, noise and non-monotonic
observations, and more. In this vignette, we'll apply the cleaned data
(`c53_mono`) to fit a trajectory function.

Let's begin by loading the library we'll be using:

```{r setup}
library(transittraj)
library(tidytransit)
library(dplyr)
library(sf)
library(ggplot2)
```

``` {r, echo = FALSE}
# --- Setup ---
c53 <- "C53"
c53_dir <- 0 # 0 is NB, 1 is SB
c53_avl <- wmata_avl %>%
  filter((route_id == c53) & (direction_id == c53_dir))
c53_gtfs <- filter_by_route(gtfs = wmata_gtfs,
                            route_ids = c53,
                            dir_id = c53_dir)
c53_NB_shape_id <- "C53:04"
dc_CRS <- 32618
c53_shape <- get_shape_geometry(gtfs = c53_gtfs,
                                shape = c53_NB_shape_id,
                                project_crs = dc_CRS)

# --- Workflow ---
c53_buffer = 50 # meters
c53_distances <- get_linear_distances(avl_df = c53_avl,
                                      shape_geometry = c53_shape,
                                      project_crs = dc_CRS,
                                      clip_buffer = c53_buffer)
c53_cleaned_subtrips <- clean_overlapping_subtrips(
  distance_df = c53_distances,
  check_operator = FALSE,
  remove_single_observations = TRUE,
  remove_non_overlapping = FALSE
)
c53_max_jump <- 20 # meters
c53_min_jump <- -1 * c53_max_jump # meters
c53_no_jumps <- clean_jumps(distance_df = c53_cleaned_subtrips,
                            max_median_deviation = c53_max_jump,
                            min_median_deviation = c53_min_jump,
                            t_cutoff = Inf)
c53_min_dist <- 500 # meters
c53_min_time <- 90 # seconds
c53_max_gap <- 500 # meters
c53_cleaned_incompletes <- clean_incomplete_trips(
  distance_df = c53_no_jumps,
  min_trip_distance = c53_min_dist,
  min_trip_duration = c53_min_time,
  max_distance_gap = c53_max_gap
)
c53_trimmed <- trim_trips(distance_df = c53_cleaned_incompletes,
                          trim_type = "both")
c53_dist_error = 0.001
c53_mono <- make_monotonic(distance_df = c53_trimmed,
                           correct_speed = TRUE,
                           add_distance_error = c53_dist_error)
```

# Fitting a Trajectory Curve

Our ultimate goal is to fit an interpolating curve describing the position of
a transit vehicle at any point in time. Ideally, we could fit an inverse curve,
giving us the time the transit vehicle passes any point in space. We can do
both using `get_trajectory_fun()`.

`transittraj` supports many different methods for fitting these functions.
The simplest is linear interpolation without an inverse. If this is all you
need, you can probably skip many of the cleaning steps from the previous
vignette. For more fine-grained analyses, though, we recommend fitting a
*velocity-informed piecewise cubic interpolating polynomial*. This uses
the speeds and distances, correct for monotonicity, to fit a cubic
spline between each observation. By default, `get_trajectory_fun()` will fit
this type of interpolating curve (`interp_method = "monoH.FC"` and
`use_speeds = TRUE`).

Using the data we cleaned in the previous vignette, let's finally fit our
trajectory functions:

``` {r}
c53_traj <- get_trajectory_fun(distance_df = c53_mono,
                               interp_method = "monoH.FC",
                               use_speeds = TRUE,
                               find_inverse_fun = TRUE)
```

And that's it! Once your data is cleaned, fitting the trajectory is quick
and easy; we've already done most of the heavy lifting.

# Exploring the Trajectory Object

`transittraj` stores the fit curves in a special object class. This object
stores a list of fit trajectories, one for each trip, as well as the time and
distances ranges for each trip. We can use `summary()` to take a look inside
the object:

``` {r}
summary(c53_traj)
```

You'll notice the summary also contains information about the parameters we
used to fit the curve.

# Interpolating

How do you use the fit curve to actually interpolate at new points? We
recommend using `predict()`, as this will ensure that the curves aren't used
to extrapolate beyond the range of each trip. Using `predict()`, there are
three main values we can interpolate for: time from distances (requires an
inverse function), distances from times, and speeds from times (requires a
spline).

## Interpolating for Times

One of the most common applications of the fit trajectory curve is to find the
time at which each vehicle passed a point along its route. To do this,
we'll use `predict()` with the `new_distances` parameter. We'll begin by
finding the distance of each stop along the route using `get_stop_distances()`:

``` {r, echo = FALSE}
c53_gtfs <- filter_by_route(wmata_gtfs,
                            route_ids = "C53", dir_id = 0)
c53_NB_shape_id <- "C53:04"
dc_CRS <- 32618
c53_shape <- get_shape_geometry(gtfs = c53_gtfs,
                                shape = c53_NB_shape_id,
                                project_crs = dc_CRS)
```

``` {r}
# First, use stop_times to find which stop_ids are timepoints
c53_timepoints <- c53_gtfs$stop_times %>%
  distinct(stop_id, timepoint)
# Now, find stop distances and join the timepoints column
c53_stops <- get_stop_distances(gtfs = c53_gtfs,
                                shape_geometry = c53_shape,
                                project_crs = dc_CRS) %>%
  left_join(y = c53_timepoints, by = "stop_id") %>%
  select(-shape_id) %>%
  mutate(timepoint = if_else(condition = (timepoint == 1),
                             true = "Yes",
                             false = "No"))
head(c53_stops)
```

Now that we have some distances, let's interpolate using `predict()`:

``` {r}
c53_stop_crossings <- predict(
  object = c53_traj,
  new_distances = c53_stops
)
head(c53_stop_crossings)
```

And now we have the crossing time (labeled `interp`) at each stop, for each
trip! The interpolated times are in seconds of epoch time.

## Interpolating for Distances

Let's say you want to know where every vehicle is at a certain point in time.
We can do that by providing `new_times` to `predict()`. Let's see below:

``` {r}
c53_time_interp <- predict(
  object = c53_traj,
  new_times = c(1771265000, 1771275000)
)
print(c53_time_interp)
```

Here, `interp` will be the distance in meters from the route's beginning.
You'll notice that, even though we have 24 trips, there were only four to five
distance for each timepoint. This is because `predict()` will only interpolate a
distance for trips that were actually running at that point in time.

## Interpolating for Speeds

The last thing we can interpolate for is the speed at any given point in time.
We can control this by setting the `deriv` parameter in `predict()`:

``` {r}
c53_speed_interp <- predict(
  object = c53_traj,
  new_times = c(1771265000, 1771275000),
  deriv = 1
)
print(c53_speed_interp)
```

Here, `interp` will be the speed in meters per second. Finding speeds requires
starting from time values.

# Visualizing Trajectories

## Quick Plots

Now its time for the *really* fun part -- plotting our trajectory curves. We
can use `plot()` to generate a quick and easy plot of all trajectories:

``` {r out.width = "100%", dpi = 600, fig.align = "center"}
plot(c53_traj)
```

`plot()` is intended for quick visualizations of trajectories, and as such does
not allow for much customization. In the next section, we'll use
`plot_trajectory()` to create more interesting plots.

## Detailed Trajectories

To add features (such as stops) and customize formatting, we recommend using
`plot_trajectory()`. This function starts of similar to `plot()`, taking a
trajectory object. After that, you can add a dataframe of feature distances,
such as the `c53_stops` we made ealier. Finally, formatting can be controlled
using mapping dataframes. The colors and linetypes of both trajectories and
features can be mapped to attributes using something similar to what is below:

``` {r}
stop_formatting <- data.frame(timepoint = c("Yes", "No"),
                              color = c("firebrick", "grey50"),
                              linetype = c("longdash", "dashed"))
```

For mapping dataframes, at least one column must match the layer being mapped
to (trajectories or features). The other columns must be `color` and/or
`linetype`, telling `transittraj` which feature they describe.

We can plug all that in to `plot_trajectory()` to generate our formatted plot:

``` {r, out.width = "100%", dpi = 600, fig.align = "center"}
traj_plot <- plot_trajectory(
  trajectory = c53_traj,
  feature_distances = c53_stops,
  feature_color = stop_formatting,
  feature_type = stop_formatting,
  feature_width = 0.2, feature_alpha = 0.5,
  traj_width = 0.4, traj_alpha = 1
)
traj_plot
```

Check out `help(plot_trajectory)` for a full discussion of the plotting features
available.

## Line Animations

Another fun way to visualize transit vehicle trajectories is to animate them.
Use `plot_line_animation()` to animate vehicles, as points, moving along a
straight line that represents the route.

The formatting process works very similarly with `plot_line_animation()` as it
does with `plot_trajector()`. The main difference is that vehicle trajectories
and features are not points, instead of lines, so we must change their
`shape` attribute, rather than `linetype`, and their `outline`, rather than
`color`:

``` {r}
stop_formatting <- data.frame(timepoint = c("Yes", "No"),
                              outline = c("firebrick", "grey30"),
                              shape = c(22, 21))
```

Now we can generate our line animation:

``` {r, eval = FALSE}
line_anim <- plot_animated_line(
  trajectory = c53_traj,
  feature_distances = c53_stops,
  feature_outline = stop_formatting,
  feature_shape = stop_formatting,
  feature_size = 2.5, feature_stroke = 1.5,
  distance_lim = c(3000, 8000)
)
```

Example coming soon.

## Map Animations

Example coming soon.
