---
title: "Introduction to Trajectories"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

In the previous vignette (`vignette("data-workflow")`), we saw how we can use
`transittraj` to clean our AVL data. We took care of outliers, deadheading
trips, noise and non-monotonic observations, and more. In this vignette, we'll
apply the cleaned data (`c53_mono`) to fit a trajectory function.

Let's begin by loading the libraries we'll be using:

```{r setup, message = FALSE, warning = FALSE}
library(transittraj)
library(tidytransit)
library(dplyr)
library(sf)
library(ggplot2)
```

``` {r, echo = FALSE}
# --- Setup ---
c53 <- "C53"
c53_dir <- 0 # 0 is NB, 1 is SB
c53_avl <- wmata_avl %>%
  filter((route_id == c53) & (direction_id == c53_dir))
c53_gtfs <- filter_by_route(gtfs = wmata_gtfs,
                            route_ids = c53,
                            dir_id = c53_dir)
c53_NB_shape_id <- "C53:04"
dc_CRS <- 32618
c53_shape <- get_shape_geometry(gtfs = c53_gtfs,
                                shape = c53_NB_shape_id,
                                project_crs = dc_CRS)

# --- Workflow ---
c53_buffer = 50 # meters
c53_distances <- get_linear_distances(avl_df = c53_avl,
                                      shape_geometry = c53_shape,
                                      project_crs = dc_CRS,
                                      clip_buffer = c53_buffer)
c53_cleaned_subtrips <- clean_overlapping_subtrips(
  distance_df = c53_distances,
  check_operator = FALSE,
  remove_single_observations = TRUE,
  remove_non_overlapping = FALSE
)
c53_max_jump <- 20 # meters
c53_min_jump <- -1 * c53_max_jump # meters
c53_no_jumps <- clean_jumps(distance_df = c53_cleaned_subtrips,
                            max_median_deviation = c53_max_jump,
                            min_median_deviation = c53_min_jump,
                            t_cutoff = Inf)
c53_min_dist <- 500 # meters
c53_min_time <- 90 # seconds
c53_max_gap <- 500 # meters
c53_cleaned_incompletes <- clean_incomplete_trips(
  distance_df = c53_no_jumps,
  min_trip_distance = c53_min_dist,
  min_trip_duration = c53_min_time,
  max_distance_gap = c53_max_gap
)
c53_trimmed <- trim_trips(distance_df = c53_cleaned_incompletes,
                          trim_type = "both")
c53_dist_error = 0.001
c53_mono <- make_monotonic(distance_df = c53_trimmed,
                           correct_speed = TRUE,
                           add_distance_error = c53_dist_error)
```

# Fitting a Trajectory Curve

Our ultimate goal is to fit an interpolating curve describing the position of
a transit vehicle at any point in time. Ideally, we could fit an inverse curve,
giving us the time the transit vehicle passes any point in space. We can do
both using `get_trajectory_fun()`.

`transittraj` supports many different methods for fitting these functions.
The simplest is linear interpolation without an inverse. If this is all you
need, you can probably skip many of the cleaning steps from the previous
vignette. For more fine-grained analyses, though, we recommend fitting a
*velocity-informed piecewise cubic interpolating polynomial*. This uses
the speeds and distances, correct for monotonicity, to fit a cubic
spline between each observation. This is the type of curve that
`get_trajectory_fun()` will fit by default (`interp_method = "monoH.FC"` and
`use_speeds = TRUE`).

Using the data we cleaned in the previous vignette, let's finally fit our
trajectory functions:

``` {r}
# Run function
c53_traj <- get_trajectory_fun(distance_df = c53_mono,
                               interp_method = "monoH.FC",
                               use_speeds = TRUE,
                               find_inverse_fun = TRUE)
```

Now we have a trajectory for each trip in `c53_mono`! Once your data is
cleaned, fitting the trajectory is quick and easy; we've already done most
of the heavy lifting.

`transittraj` stores the fit curves in a special object class. This object
stores a list of fit trajectories, one for each trip, as well as the time and
distances ranges for each trip. We can use `summary()` to take a look inside
the object:

``` {r}
summary(c53_traj)
```

You'll notice the summary also contains information about the parameters we
used to fit the curve.

# Interpolating

How do you use the fit curve to actually interpolate at new points? We
recommend using `predict()`, as this will ensure that the curves aren't used
to extrapolate beyond the range of each trip. Using `predict()`, there are
three main values we can interpolate for: time from distances (requires an
inverse function), distances from times, and speeds from times (requires a
spline).

## Interpolating for Times

One of the most common applications of the fit trajectory curve is to find the
time at which each vehicle passed a point along its route. To do this,
we'll use `predict()` with the `new_distances` parameter. We'll begin by
finding the distance of each stop along the route using `get_stop_distances()`:

``` {r}
# First, use stop_times to find which stop_ids are timepoints
c53_timepoints <- c53_gtfs$stop_times %>%
  distinct(stop_id, timepoint)

# Now, find stop distances and join the timepoints column
c53_stops <- get_stop_distances(gtfs = c53_gtfs,
                                shape_geometry = c53_shape,
                                project_crs = dc_CRS) %>%
  # Join timepoint info & stop name to each stop ID
  left_join(y = c53_timepoints,
            by = "stop_id") %>%
  left_join(y = (c53_gtfs$stops %>% select(stop_id, stop_name)),
            by = "stop_id") %>%
  # Polish up the result
  select(-shape_id) %>%
  mutate(timepoint = if_else(condition = (timepoint == 1),
                             true = "Yes",
                             false = "No"))

# Print header
head(c53_stops)
```

Now that we have some distances, let's interpolate using `predict()`:

``` {r}
# Run interpolating function
c53_stop_crossings <- predict(
  object = c53_traj,
  new_distances = c53_stops
)

# Print header
head(c53_stop_crossings)
```

Now we have the crossing time, labeled `interp` at each stop for each trip.
The interpolated times are in seconds of epoch time.

## Interpolating for Distances

Let's say you want to know where every vehicle is at a certain point in time.
We can do that by providing `new_times` to `predict()`. Let's see below:

``` {r}
# Run interpolating function
c53_time_interp <- predict(
  object = c53_traj,
  new_times = c(1771265000, 1771275000)
)

# Print full results
print(c53_time_interp)
```

Here, `interp` will be the distance in meters from the route's beginning.
You'll notice that, even though we have 24 trips, there were only four to five
distance for each timepoint. This is because `predict()` will only interpolate a
distance value for trips that were actually running at that point in time.

## Interpolating for Speeds

The last thing we can interpolate for is the speed at any given point in time.
We can control this by setting the `deriv` parameter in `predict()`:

``` {r}
# Run interpolating function
c53_speed_interp <- predict(
  object = c53_traj,
  new_times = c(1771265000, 1771275000),
  deriv = 1
)

# Print results
print(c53_speed_interp)
```

Here, `interp` will be the speed in meters per second. Finding speeds requires
starting from time values; we cannot get speeds from distance values.

# Visualizing Trajectories

## Quick Plots

Now its time for the *really* fun part -- plotting our trajectory curves. We
can use `plot()` to generate a quick and easy plot of all trajectories:

``` {r out.width = "100%", dpi = 600, fig.align = "center"}
plot(c53_traj)
```

`plot()` is intended for quick visualizations of trajectories, and as such does
not allow for much customization. In the next section, we'll use
`plot_trajectory()` to create more interesting plots.

## Detailed Trajectories

To add features (such as stops) and customize formatting, we recommend using
`plot_trajectory()`. This function starts of similar to `plot()`, taking a
trajectory object. After that, you can add a dataframe of feature distances,
such as the `c53_stops` we made ealier. Finally, formatting can be controlled
using mapping dataframes. The colors and linetypes of both trajectories and
features can be mapped to attributes using something similar to what is below:

``` {r}
# Set formatting options for C53 stops
stop_formatting <- data.frame(timepoint = c("Yes", "No"),
                              color = c("firebrick", "grey50"),
                              linetype = c("longdash", "dashed"))
```

For mapping dataframes, at least one column must match the layer being mapped
to (trajectories or features). The other columns must be `color` and/or
`linetype`, telling `transittraj` which feature they describe.

We can plug all that in to `plot_trajectory()` to generate our formatted plot:

``` {r, out.width = "100%", dpi = 600, fig.align = "center"}
# Run plotting function
traj_plot <- plot_trajectory(
  # Provide input data
  trajectory = c53_traj,
  feature_distances = c53_stops,
  # Format features
  feature_color = stop_formatting,
  feature_type = stop_formatting,
  feature_width = 0.2, feature_alpha = 0.5,
  # Format trajectories
  traj_width = 0.4, traj_alpha = 1
)
traj_plot
```

That's a lot of trajectories, and it's hard to see what's actually going on.
The benefits of the cleaning we did, and of fitting a spline trajectory, become
much more apparent when we zoom in. Below we use the `distance_lim` parameter
to zoom into the intersection of Florida Ave & U St. This is a large 
intersection with complex geometry and stops on either side. Additionally,
we'll center each trajectory to start at the same point in time using
`center_trajectories`. This lets us visualize the distribution of travel times
along a corridor.

``` {r, out.width = "100%", dpi = 600, fig.align = "center"}
# Set parameters
#am_lims <- c(13900, 14600)
fl_U_intersection_lims <- c(12000, 12600)

# Run function
traj_plot2 <- plot_trajectory(
  # Provide input data
  trajectory = c53_traj,
  feature_distances = c53_stops,
  center_trajectories = TRUE,
  distance_lim = fl_U_intersection_lims,
  timestep = 1,
  # Format fetures
  feature_color = stop_formatting,
  feature_type = stop_formatting,
  feature_width = 1, feature_alpha = 0.8,
  # Format trajectories
  traj_width = 0.6, traj_alpha = 0.6,
  # Add labels
  label_field = "stop_name", label_pos = "right"
)
traj_plot2
```

We can glean some insights from this. Almost every trip stops at Florida &
Georgia, either to serve the stop or wait for the signal. One trip sits there
for a particularly long time. A handful of others stop at the signal in between
these two stops, and a couple more stop at U & Vermont. A few trips have
intermittent slowdown between these stops and signals, potentially due to
other congestion sources.

There are many formatting features available through `plot_trajectory()`. Check
out `help(plot_trajectory)` for a full discussion.

## Line Animations

Another fun way to visualize transit vehicle trajectories is to animate them.
Use `plot_animated_line()` to animate vehicles, as points, moving along a
straight line that represents the route.

The formatting process works very similarly with `plot_animated_line()` as it
does with `plot_trajectory()`. For this plot, we'll also set some distance
limits to zoom in to the Florida Ave-U St corridor of the route.

``` {r}
# Set parameters
stop_formatting <- data.frame(timepoint = c("Yes", "No"),
                              outline = c("red1", "grey30"),
                              shape = c(22, 21))
fl_U_corridor_lims <- c(9500, 15500)
```

Now we can generate our line animation. We'll use the field `label_field` to
tell the function to label each stop point with the `stop_name` column in
`c53_stops`:

``` {r, eval = FALSE}
# Run function
line_anim <- plot_animated_line(
  # Add input data
  trajectory = c53_traj,
  feature_distances = c53_stops,
  distance_lim = fl_U_corridor_lims,
  timestep = 1,
  # Format features
  feature_outline = stop_formatting,
  feature_shape = stop_formatting,
  feature_size = 3, feature_stroke = 1.5,
  # Add labels
  label_field = "stop_name",
  label_pos = "right", label_size = 3,
  # Format route & vehicles
  route_color = "indianred2",
  veh_alpha = 0.9, veh_size = 4
)
line_anim
```

``` {r eval = FALSE, echo = FALSE}
gganimate::animate(line_anim,
                   duration = 60, fps = 30,
                   height = 1080, width = 350, units = "px",
                   renderer = gganimate::av_renderer())
```

``` {r, echo = FALSE}
library(vembedr)
embed_url("https://www.youtube.com/watch?v=WP4F62O9gws") %>%
  use_align("center")
```

The animation shows us that most trips stop primarily at their stops, either due
to signals or to serve the stop. There are, though, occasional slow downs
between these stops. You can even see that trip that sits at Florida & Georgia
for a long time (at around 0:16 seconds).

You'll also notice that we've uploaded this animation to YouTube and embedded
it in the vignette. We did this so we could produce a smooth, high-resolution
video that doesn't need to be re-rendered every time this vignette is built. By
default, `transittraj`'s animation functions will return a `gif`. Check out
`gganimate::animate()` for options to render videos.

## Map Animations

The final visualization we'll make is an animated map. The concept is similar
to the animated line we saw above, but instead of simplifying the route,
we'll draw it spatially and show the vehicles traveling through the city.

The function `plot_animated_map()` has formatting and feature options very
similar to the previous two visualization functions. We can reuse the
formatting options from `plot_animated_line()` here.

``` {r, eval = FALSE}
# Run function
map_anim <- plot_animated_map(
  # Add trajectory, shape, & feature data
  trajectory = c53_traj,
  shape_geometry = c53_shape,
  feature_distances = c53_stops,
  # Format features
  feature_outline = stop_formatting,
  feature_shape = stop_formatting,
  feature_size = 3, feature_stroke = 2,
  # Format route
  route_color = "indianred3", route_width = 4,
  bbox_expand = 700,
  # Format vehicles
  veh_size = 6, veh_stroke = 3, veh_alpha = 0.9
)
map_anim
```

``` {r, echo = FALSE, eval = FALSE}
gganimate::animate(map_anim,
                   duration = 60, fps = 30,
                   height = 1080, width = 920, units = "px",
                   renderer = gganimate::av_renderer())
```

``` {r, echo = FALSE}
embed_url("https://www.youtube.com/watch?v=SKOE7F-oSnY") %>%
  use_align("center")
```

This animation gives us a route-level that makes it easier to tell where we
actually are (though you can zoom in to a specific distance range, like
before). We can start to see, spatially where buses start to bunch together,
such as the two vehicles entering Florida at around 0:34 seconds, or the three
vehicles near Florida at around 0:45 seconds.

# Conclusion

In this vignette we saw how we can easily fit an interpolating trajectory
curve to our cleaned AVL data. We used this to interpolate for new time,
distance, and speed points along the route. We also explored some ways we can
plot and visualize the trajectories. In future vignettes 
(*still work in progress*), we'll dive deeper into the structure behind the
trajectory object, as well as the options available in `transittraj`'s plotting
functions.
